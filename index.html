<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>음계 측정기 1.2</title>
<style>
  body { font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; padding: 2rem; background-color: #f4f4f9; }
  h1 { color: #333; }
  button, input[type=range] { margin: 0.5rem; padding: 0.8rem 1.5rem; font-size: 1rem; border-radius: 5px; border: 1px solid #ccc; cursor: pointer; }
  button { background-color: #007bff; color: white; }
  button:disabled { background-color: #aaa; }
  #toggleRecordingBtn.recording { background-color: #dc3545; }
  #pitch { font-size: 1.5rem; margin-top: 1rem; font-weight: bold; color: #333; }
  #status { margin-top: 1rem; font-weight: bold; color: #555; }
  div { margin-bottom: 1rem; text-align: center; }
  label { font-size: 0.9rem; color: #666; }
</style>
</head>
<body>
<h1>음계 측정기 1.2</h1>

<button id="toggleRecordingBtn">녹음 시작</button>

<div>
  <label for="bpm">BPM 설정: <span id="bpmVal">100</span></label><br/>
  <input type="range" id="bpm" min="40" max="208" value="100" />
  <button id="toggleMetronomeBtn">메트로놈 켜기</button>
</div>
<div>
  <label for="soundSlider">메트로놈 소리: <span id="soundVal">100</span></label><br/>
  <input type="range" id="soundSlider" min="0" max="100" value="100" />
</div>

<div id="pitch">음계: -- | 주파수: -- Hz</div>
<div id="status">마이크를 시작하려면 녹음 버튼을 눌러주세요.</div>
<audio id="metronomeSound" src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg" preload="auto"></audio>

<script>
const toggleRecordingBtn = document.getElementById('toggleRecordingBtn');
const bpmSlider = document.getElementById('bpm');
const bpmVal = document.getElementById('bpmVal');
const toggleMetronomeBtn = document.getElementById('toggleMetronomeBtn');
const pitchDiv = document.getElementById('pitch');
const statusDiv = document.getElementById('status');
const metronomeSound = document.getElementById('metronomeSound');
const soundSlider = document.getElementById('soundSlider');
const soundVal = document.getElementById('soundVal');

let audioContext, analyser, microphone, scriptProcessor, mediaStream;
let metronomeInterval = null;
let isMetronomeOn = false;
let isRecording = false; // 녹음 상태를 추적하는 변수
let pitchHistory = [];
const maxHistory = 10;

// --- 오디오 처리 및 음계 분석 함수 ---
function autoCorrelate(buffer, sampleRate) {
  let SIZE = buffer.length;
  let MAX_SAMPLES = Math.floor(SIZE / 2);
  let bestOffset = -1;
  let bestCorrelation = 0;
  let rms = 0;
  let foundGoodCorrelation = false;
  let correlations = new Array(MAX_SAMPLES);

  for (let i = 0; i < SIZE; i++) {
    let val = buffer[i];
    rms += val * val;
  }
  rms = Math.sqrt(rms / SIZE);
  if (rms < 0.01) return -1;

  let lastCorrelation = 1;
  for (let offset = 0; offset < MAX_SAMPLES; offset++) {
    let correlation = 0;
    for (let i = 0; i < MAX_SAMPLES; i++) {
      correlation += Math.abs(buffer[i] - buffer[i + offset]);
    }
    correlation = 1 - (correlation / MAX_SAMPLES);
    correlations[offset] = correlation;

    if (correlation > 0.9 && correlation > lastCorrelation) {
      foundGoodCorrelation = true;
      if (correlation > bestCorrelation) {
        bestCorrelation = correlation;
        bestOffset = offset;
      }
    } else if (foundGoodCorrelation) {
      let shift = (correlations[bestOffset + 1] - correlations[bestOffset - 1]) / correlations[bestOffset];
      return sampleRate / (bestOffset + 8 * shift);
    }
    lastCorrelation = correlation;
  }
  if (bestCorrelation > 0.01) {
    return sampleRate / bestOffset;
  }
  return -1;
}

function frequencyToNote(freq) {
  if (freq === -1) return "--";
  const noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
  let noteNum = 12 * (Math.log2(freq / 440)) + 69;
  let noteIndex = Math.round(noteNum) % 12;
  let octave = Math.floor(Math.round(noteNum) / 12) - 1;
  return noteStrings[noteIndex] + octave;
}

function weightedAverage(arr){
  let weightSum = 0;
  let weightedValSum = 0;
  for(let i=0; i<arr.length; i++){
    let weight = i + 1;
    weightSum += weight;
    weightedValSum += arr[i] * weight;
  }
  return weightedValSum / weightSum;
}

// --- 메트로놈 및 UI 제어 함수 ---
bpmSlider.oninput = () => {
  bpmVal.textContent = bpmSlider.value;
  if (isMetronomeOn) {
    stopMetronome();
    startMetronome();
  }
};

//볼륨 슬라이더 기능 추가
soundSlider.oninput = () => {
  const volume = soundSlider.value / 100;
  soundVal.textContent = soundSlider.value;
  metronomeSound.volume = volume;
};

function startMetronome() {
  let intervalMs = Math.floor(60000 / bpmSlider.value);
  if (metronomeInterval) clearInterval(metronomeInterval);
  metronomeInterval = setInterval(() => {
    metronomeSound.currentTime = 0;
    metronomeSound.play();
  }, intervalMs);
  toggleMetronomeBtn.textContent = "메트로놈 끄기";
  isMetronomeOn = true;
  statusDiv.textContent = `메트로놈 작동 중 (BPM: ${bpmSlider.value})`;
}

function stopMetronome() {
  clearInterval(metronomeInterval);
  metronomeInterval = null;
  toggleMetronomeBtn.textContent = "메트로놈 켜기";
  isMetronomeOn = false;
  if(isRecording) {
      statusDiv.textContent = "마이크 활성화 및 음성 분석 중";
  } else {
      statusDiv.textContent = "메트로놈 정지됨";
  }
}

toggleMetronomeBtn.onclick = () => {
  if (isMetronomeOn) stopMetronome();
  else startMetronome();
};

// --- 녹음 시작/중지 ---
async function startRecording() {
  try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    microphone = audioContext.createMediaStreamSource(mediaStream);
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    scriptProcessor = audioContext.createScriptProcessor(2048, 1, 1);

    microphone.connect(analyser);
    analyser.connect(scriptProcessor);
    scriptProcessor.connect(audioContext.destination);

    scriptProcessor.onaudioprocess = () => {
      let array = new Float32Array(analyser.fftSize);
      analyser.getFloatTimeDomainData(array);
      let pitch = autoCorrelate(array, audioContext.sampleRate);
      
      if (pitch !== -1) {
        pitchHistory.push(pitch);
        if (pitchHistory.length > maxHistory) pitchHistory.shift();
        let avgPitch = weightedAverage(pitchHistory);
        pitchDiv.textContent = `음계: ${frequencyToNote(avgPitch)} | 주파수: ${avgPitch.toFixed(2)} Hz`;
      }
    };

    isRecording = true;
    toggleRecordingBtn.textContent = "녹음 중지";
    toggleRecordingBtn.classList.add('recording');
    statusDiv.textContent = "마이크 활성화 및 음성 분석 중";
  } catch (err) {
    statusDiv.textContent = "마이크 권한 오류. 새로고침 후 다시 시도하세요.";
    console.error(err);
  }
}

// 녹음 중지 기능 추가
function stopRecording() {
  if (mediaStream) {
    mediaStream.getTracks().forEach(track => track.stop()); // 마이크 사용 중지
  }
  if (microphone) microphone.disconnect();
  if (scriptProcessor) scriptProcessor.disconnect();
  if (audioContext) audioContext.close(); // AudioContext 자원 해제

  isRecording = false;
  pitchHistory = []; // 기록 초기화
  toggleRecordingBtn.textContent = "녹음 시작";
  toggleRecordingBtn.classList.remove('recording');
  pitchDiv.textContent = `음계: -- | 주파수: -- Hz`;
  statusDiv.textContent = "녹음이 중지되었습니다. 다시 시작하려면 버튼을 누르세요.";
}

// 하나의 버튼으로 시작/중지 토글
toggleRecordingBtn.onclick = () => {
  if (isRecording) {
    stopRecording();
  } else {
    startRecording();
  }
};

// 페이지 로드 시 초기 볼륨 설정
document.addEventListener('DOMContentLoaded', () => {
    metronomeSound.volume = soundSlider.value / 100;
});

</script>
<footer style="position: fixed; bottom: 5px; width: 100%; text-align: center; font-size: 0.8rem; color: #888;">
  <a href="https://instagram.com/rei_tuyu" target="_blank" style="color: #555; text-decoration: none;">@rei_tuyu - 음계 측정기 1.2</a>
</footer>
</body>
</html>